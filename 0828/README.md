# 统计字串中的唯一字符

记录一下思路

## 开始解题

定义`map[i][j]`代表串中从`i`到`j`的唯一字符个数，则结果为整个`map`数组的和。

为了计算`map`，定义`last[i]`代表串中第`i`个字符上一次出现的位置，则`map[i][j]`的值只需要遍历`last[i..j]`，如果`last[k]`的值不小于`i`，说明该字符已经在`last[i..k-1]`中出现过，所以计数需要减一，但是因为这个字符可能在`last[i..k-1]`中出现过，导致多次删减，所以需要拿到`last[last[k]-1]`的值与`i`比较，当且仅当`last[last[k]-1]`不大于起点`i`，计数需要减一。

为了计算`last`，定义`at[char]`代表字符char在字符串中最后一次出现的位置，在遍历的过程中不断更新`at`值与`last`，最终有了本题的第一次提交。

## 第一次超时优化

观察代码发现`map[i][j]`的求和过程，如果对调`i`和`j`，循环条件和串遍历是一样的，所以可以把求和过程也累积到遍历中。

这时`map[i][j-1]`的存储已经没有价值，可以把`map[i][j]`降维，新的一维数组`map[i]`的定义为从`i`到当前遍历字符的唯一字符个数。

## 第二次超时优化

继续观察发现每一次对map的求和过程都是重复的，可以把`ans += map[i]`抽离到循环之外，定义`sum`为串中已经遍历过的任意字符到当前字符的`唯一字符`之和后，则对每一个`map[i]`的修改最中也都会写入结果`sum`中，每一项`map[i]`的定义并不会被真正关注，可以直接移除，将一维数组降维到变量。



