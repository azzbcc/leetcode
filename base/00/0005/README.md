# 最长回文字串

一开始有些卡题，总想着一个优化方案能够直接计算结果。最后还是用了最基础的方法。

定义`data[i][j]`标识串从`i`到`j`是否回文字符串，状态转义方程为：

`data[i][j] = str[i] == str[j] && data[i+1][j-1]`

耗时只击败了`41%`的用户，内存更是只有`14%`，还有巨大的提升空间。

## 优化

了解到[Manacher算法](https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2)可以线性求解最长回文子串问题。

查阅了一些资料，相比KMP，其实Manacher还要更简单一些。

定义`S`表示源串，`C`表示上一个回文子串中心位置座标，`R`表示上一个回文子串终点位置座标，`B`表示回文子串从终点(或起点)到回文子串中心的长度距离。

上一个回文串右臂上某点座标`P`, 其在上一个回文字串的左臂对应位置为`P'`，`R - P` 与 `B[P']` 大小关系有以下可能：

1. `R - P > B[P']` 则`B[P] = B[P']` 回文串以`C`点对称，左臂上某子串和右臂对称，字串臂长相同。
2. `R - P < B[P']` 则`B[P] = R - P` 假如`B[P] > R - P`，因为以`C`点对称特性，必有`S[R + 1] == S[R' - 1]`，与`R`为回文子串终点相悖。
3. `R - P = B[P']` 则`B[P] >= R - P` 此时`B[P]`未知，以当前点作为新的`C`值，并更新相应的`R`位置。

为了规避偶数长度回文串，我们在源串每两个字符之间添加一个未知字符，最终的最大臂长即为最长回文串长度。

使用Manacher算法，最终将时间复杂度降低到O(N)。