# 统计字串中的唯一字符

记录一下思路

## 开始解题

定义`map[i][j]`代表串中从`i`到`j`的唯一字符个数，则结果为整个`map`数组的和。

为了计算`map`，定义`last[i]`代表串中第`i`个字符上一次出现的位置，则`map[i][j]`的值只需要遍历`last[i..j]`，如果`last[k]`的值不小于`i`，说明该字符已经在`last[i..k-1]`中出现过，所以计数需要减一，但是因为这个字符可能在`last[i..k-1]`中出现过，导致多次删减，所以需要拿到`last[last[k]-1]`的值与`i`比较，当且仅当`last[last[k]-1]`不大于起点`i`，计数需要减一。

为了计算`last`，定义`at[char]`代表字符char在字符串中最后一次出现的位置，在遍历的过程中不断更新`at`值与`last`，最终有了本题的第一次提交。

## 第一次超时优化

观察代码发现`map[i][j]`的求和过程，如果对调`i`和`j`，循环条件和串遍历是一样的，所以可以把求和过程也累积到遍历中。

这时`map[i][j-1]`的存储已经没有价值，可以把`map[i][j]`降维，新的一维数组`map[i]`的定义为从`i`到当前遍历字符的唯一字符个数。

## 第二次超时优化

继续观察发现每一次对map的求和过程都是重复的，可以把`ans += map[i]`抽离到循环之外，定义`sum`为串中已经遍历过的任意字符到当前字符的`唯一字符`之和后，则对每一个`map[i]`的修改最中也都会写入结果`sum`中，每一项`map[i]`的定义并不会被真正关注，可以直接移除，将一维数组降维到变量。

## 第三次超时优化

继续观察发现虽然循环中我们对`sum`的值有加有减，但判断条件的右值均为`j`，可以将多次运算独立到循环外。

```
sum += i + 1;
if (last[i] > 0) {
    sum -= 2 * last[i] - last[last[i] - 1];
}
```

## 总结

最终将时间复杂度优化到`O(n)`，A掉此题。

从题目层面理解，每次对已有串追加第`k`个字符时，有三种情况
1. 字符尚未出现过，则所有以该字符结尾的串的唯一字符个数为`sum+k`。
2. 字符出现过一次，上一次出现位置为`a`，其中前`a`个字符开始的串的唯一字符个数为`-a`，后`k-a`个字符开始的串的唯一字符个数为`k-a`，则所有以该字符结尾的串的唯一字符个数为 `sum+k-2a`。
3. 字符出现过多次，上一次出现位置为`a`，上上次出现位置为`b`，因为以前`b`个字符开始串的唯一字符个数不变，中间`a-b`个字符开始的串的唯一字符个数为`b-a`，后`k-a`个字符开始的串的唯一字符个数为`k-a`，则所有以该字符结尾的串的唯一字符个数为 `sum+k-2a+b`。

## 补充优化

总结发现`last`数组冗余，只需要记录每一个字符上一次和上上次出现的位置即可。