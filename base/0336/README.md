# 回文对

## 题目解析

把两个字符串拼接成一个回文串，反过来思考，是把一个回文串分割成`a`, `b`两部分，则`a`、`b`长度大小关系为：
1. `len(a) = len(b)`，则 `a = reverse(b)`，`a`与`b`互为逆序。
2. `len(a) > len(b)`，则 `a = reverse(b) + S`，其中`S`为任意回文字符串。
3. `len(a) < len(b)`，则 `b = S + reverse(a)`，其中`S`为任意回文字符串。

另外需注意：在情况`2`和`3`中，`a`、`b`以及`S`均有可能为空字符串。

在情况`2`与`3`中，当`S`为空字符串，`a`与`b`互为逆序，与情况`1`相同，所以不能再做记录。

>针对情况`1`，可以对数组中每一个字符串逆序，然后查找数组中是否存在其逆序字符串，如果有，则记录两者下标。
>
>针对情况`2`，遍历每一个字符串，找到其任意非空回文子串`S`，且`S`是字符串后缀。然后查找数组中是否存在剩余部分的逆序字符串，如果有，则记录两者下标。
>
>针对情况`3`，遍历每一个字符串，找到其任意非空回文子串`S`，且`S`是字符串前缀。然后查找数组中是否存在剩余部分的逆序字符串，如果有，则记录两者下标。

至此此题可解。

## 优化

题中多次出现在数组查找某字符串的逆序操作，为了加速查询效率，可以使用哈希表或者前缀树，加快查找速度。

我们使用前缀树解决，并定义`trie_reverse_search`方法，提供树、字符串、字符串开始和结束位置4个参数，从字符串结束位置找到开始，最终返回查找到的树节点，规避逆序操作。