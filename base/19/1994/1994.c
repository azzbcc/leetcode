// 给你一个整数数组 nums 。如果 nums 的一个子集中，所有元素的乘积可以表示为一个或多个 互不相同的质数
// 的乘积，那么我们称它为 好子集 。
//
//
// 比方说，如果 nums = [1, 2, 3, 4] ：
//
//
// [2, 3] ，[1, 2, 3] 和 [1, 3] 是 好 子集，乘积分别为 6 = 2*3 ，6 = 2*3 和 3 = 3 。
// [1, 4] 和 [4] 不是 好 子集，因为乘积分别为 4 = 2*2 和 4 = 2*2 。
//
//
//
//
// 请你返回 nums 中不同的 好 子集的数目对 10⁹ + 7 取余 的结果。
//
// nums 中的 子集 是通过删除 nums
// 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。
//
//
//
// 示例 1：
//
//
// 输入：nums = [1,2,3,4]
// 输出：6
// 解释：好子集为：
// - [1,2]：乘积为 2 ，可以表示为质数 2 的乘积。
// - [1,2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
// - [1,3]：乘积为 3 ，可以表示为质数 3 的乘积。
// - [2]：乘积为 2 ，可以表示为质数 2 的乘积。
// - [2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
// - [3]：乘积为 3 ，可以表示为质数 3 的乘积。
//
//
// 示例 2：
//
//
// 输入：nums = [4,2,3,15]
// 输出：5
// 解释：好子集为：
// - [2]：乘积为 2 ，可以表示为质数 2 的乘积。
// - [2,3]：乘积为 6 ，可以表示为互不相同质数 2 和 3 的乘积。
// - [2,15]：乘积为 30 ，可以表示为互不相同质数 2，3 和 5 的乘积。
// - [3]：乘积为 3 ，可以表示为质数 3 的乘积。
// - [15]：乘积为 15 ，可以表示为互不相同质数 3 和 5 的乘积。
//
//
//
//
// 提示：
//
//
// 1 <= nums.length <= 10⁵
// 1 <= nums[i] <= 30
//
// Related Topics 位运算 数组 数学 动态规划 状态压缩 👍 70 👎 0

#define MAXN 30
#define MAXM 10
#define MOD  1000000007
int numberOfGoodSubsets(int *nums, int size) {
    int cs[MAXN + 1] = { 0 }, ans = 0, dp[0x1 << MAXM] = { 1 };
    struct {
        int key, mask;
    } cm[] = {
        { 2, 0x1 << 0 },
        { 3, 0x1 << 1 },
        { 5, 0x1 << 2 },
        { 6, 0x1 << 0 | 0x1 << 1 },
        { 7, 0x1 << 3 },
        { 10, 0x1 << 0 | 0x1 << 2 },
        { 11, 0x1 << 4 },
        { 13, 0x1 << 5 },
        { 14, 0x1 << 0 | 0x1 << 3 },
        { 15, 0x1 << 1 | 0x1 << 2 },
        { 17, 0x1 << 6 },
        { 19, 0x1 << 7 },
        { 21, 0x1 << 1 | 0x1 << 3 },
        { 22, 0x1 << 0 | 0x1 << 4 },
        { 23, 0x1 << 8 },
        { 26, 0x1 << 0 | 0x1 << 5 },
        { 29, 0x1 << 9 },
        { 30, 0x1 << 0 | 0x1 << 1 | 0x1 << 2 },
    };
    for (int i = 0; i < size; cs[nums[i++]]++) {}
    for (int i = 0; i < sizeof(cm) / sizeof(cm[0]); ++i) {
        for (int j = 0; j < 0x1 << MAXM; ++j) {
            if ((j & cm[i].mask) != cm[i].mask) continue;
            dp[j] = (dp[j] + ( long )dp[j ^ cm[i].mask] * cs[cm[i].key]) % MOD;
        }
    }
    for (int i = 1; i < 0x1 << MAXM; ans = (ans + dp[i++]) % MOD) {}
    for (; cs[1]--; ans = ans * 2 % MOD) {}

    return ans;
}
