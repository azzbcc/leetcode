// åŸå¸‚ç”¨ä¸€ä¸ª åŒå‘è¿é€š å›¾è¡¨ç¤ºï¼Œå›¾ä¸­æœ‰ n ä¸ªèŠ‚ç‚¹ï¼Œä» 1 åˆ° n ç¼–å·ï¼ˆåŒ…å« 1 å’Œ nï¼‰ã€‚å›¾ä¸­çš„è¾¹ç”¨ä¸€ä¸ªäºŒç»´æ•´æ•°æ•°ç»„ edges
// è¡¨ç¤ºï¼Œå…¶ä¸­æ¯ä¸ª edges[i] = [ui, vi] è¡¨ç¤ºä¸€æ¡èŠ‚ç‚¹ ui å’ŒèŠ‚ç‚¹ vi ä¹‹é—´çš„åŒå‘è¿é€šè¾¹ã€‚æ¯ç»„èŠ‚ç‚¹å¯¹ç”± æœ€å¤šä¸€æ¡
// è¾¹è¿é€šï¼Œé¡¶ç‚¹ä¸å­˜åœ¨è¿æ¥åˆ°è‡ªèº«çš„è¾¹ã€‚ç©¿è¿‡ä»»æ„ä¸€æ¡è¾¹çš„æ—¶é—´æ˜¯ time åˆ†é’Ÿã€‚
//
// æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªäº¤é€šä¿¡å·ç¯ï¼Œæ¯ change åˆ†é’Ÿæ”¹å˜ä¸€æ¬¡ï¼Œä»ç»¿è‰²å˜æˆçº¢è‰²ï¼Œå†ç”±çº¢è‰²å˜æˆç»¿è‰²ï¼Œå¾ªç¯å¾€å¤ã€‚æ‰€æœ‰ä¿¡å·ç¯éƒ½ åŒæ—¶
// æ”¹å˜ã€‚ ä½ å¯ä»¥åœ¨ ä»»ä½•æ—¶å€™ è¿›å…¥æŸä¸ªèŠ‚ç‚¹ï¼Œä½†æ˜¯ åªèƒ½ åœ¨èŠ‚ç‚¹ ä¿¡å·ç¯æ˜¯ç»¿è‰²æ—¶ æ‰èƒ½ç¦»å¼€ã€‚å¦‚æœä¿¡å·ç¯æ˜¯ ç»¿è‰² ï¼Œä½  ä¸èƒ½
// åœ¨èŠ‚ç‚¹ç­‰å¾…ï¼Œå¿…é¡»ç¦»å¼€ã€‚
//
// ç¬¬äºŒå°çš„å€¼ æ˜¯ ä¸¥æ ¼å¤§äº æœ€å°å€¼çš„æ‰€æœ‰å€¼ä¸­æœ€å°çš„å€¼ã€‚
//
//
// ä¾‹å¦‚ï¼Œ[2, 3, 4] ä¸­ç¬¬äºŒå°çš„å€¼æ˜¯ 3 ï¼Œè€Œ [2, 2, 4] ä¸­ç¬¬äºŒå°çš„å€¼æ˜¯ 4 ã€‚
//
//
// ç»™ä½  nã€edgesã€time å’Œ change ï¼Œè¿”å›ä»èŠ‚ç‚¹ 1 åˆ°èŠ‚ç‚¹ n éœ€è¦çš„ ç¬¬äºŒçŸ­æ—¶é—´ ã€‚
//
// æ³¨æ„ï¼š
//
//
// ä½ å¯ä»¥ ä»»æ„æ¬¡ ç©¿è¿‡ä»»æ„é¡¶ç‚¹ï¼ŒåŒ…æ‹¬ 1 å’Œ n ã€‚
// ä½ å¯ä»¥å‡è®¾åœ¨ å¯ç¨‹æ—¶ ï¼Œæ‰€æœ‰ä¿¡å·ç¯åˆšåˆšå˜æˆ ç»¿è‰² ã€‚
//
//
//
//
// ç¤ºä¾‹ 1ï¼š
//
//
//
//
// è¾“å…¥ï¼šn = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5
// è¾“å‡ºï¼š13
// è§£é‡Šï¼š
// ä¸Šé¢çš„å·¦å›¾å±•ç°äº†ç»™å‡ºçš„åŸå¸‚äº¤é€šå›¾ã€‚
// å³å›¾ä¸­çš„è“è‰²è·¯å¾„æ˜¯æœ€çŸ­æ—¶é—´è·¯å¾„ã€‚
// èŠ±è´¹çš„æ—¶é—´æ˜¯ï¼š
// - ä»èŠ‚ç‚¹ 1 å¼€å§‹ï¼Œæ€»èŠ±è´¹æ—¶é—´=0
// - 1 -> 4ï¼š3 åˆ†é’Ÿï¼Œæ€»èŠ±è´¹æ—¶é—´=3
// - 4 -> 5ï¼š3 åˆ†é’Ÿï¼Œæ€»èŠ±è´¹æ—¶é—´=6
// å› æ­¤éœ€è¦çš„æœ€å°æ—¶é—´æ˜¯ 6 åˆ†é’Ÿã€‚
//
// å³å›¾ä¸­çš„çº¢è‰²è·¯å¾„æ˜¯ç¬¬äºŒçŸ­æ—¶é—´è·¯å¾„ã€‚
// - ä»èŠ‚ç‚¹ 1 å¼€å§‹ï¼Œæ€»èŠ±è´¹æ—¶é—´=0
// - 1 -> 3ï¼š3 åˆ†é’Ÿï¼Œæ€»èŠ±è´¹æ—¶é—´=3
// - 3 -> 4ï¼š3 åˆ†é’Ÿï¼Œæ€»èŠ±è´¹æ—¶é—´=6
// - åœ¨èŠ‚ç‚¹ 4 ç­‰å¾… 4 åˆ†é’Ÿï¼Œæ€»èŠ±è´¹æ—¶é—´=10
// - 4 -> 5ï¼š3 åˆ†é’Ÿï¼Œæ€»èŠ±è´¹æ—¶é—´=13
// å› æ­¤ç¬¬äºŒçŸ­æ—¶é—´æ˜¯ 13 åˆ†é’Ÿã€‚
//
//
// ç¤ºä¾‹ 2ï¼š
//
//
//
//
// è¾“å…¥ï¼šn = 2, edges = [[1,2]], time = 3, change = 2
// è¾“å‡ºï¼š11
// è§£é‡Šï¼š
// æœ€çŸ­æ—¶é—´è·¯å¾„æ˜¯ 1 -> 2 ï¼Œæ€»èŠ±è´¹æ—¶é—´ = 3 åˆ†é’Ÿ
// æœ€çŸ­æ—¶é—´è·¯å¾„æ˜¯ 1 -> 2 -> 1 -> 2 ï¼Œæ€»èŠ±è´¹æ—¶é—´ = 11 åˆ†é’Ÿ
//
//
//
// æç¤ºï¼š
//
//
// 2 <= n <= 10â´
// n - 1 <= edges.length <= min(2 * 10â´, n * (n - 1) / 2)
// edges[i].length == 2
// 1 <= ui, vi <= n
// ui != vi
// ä¸å«é‡å¤è¾¹
// æ¯ä¸ªèŠ‚ç‚¹éƒ½å¯ä»¥ä»å…¶ä»–èŠ‚ç‚¹ç›´æ¥æˆ–è€…é—´æ¥åˆ°è¾¾
// 1 <= time, change <= 10Â³
//
// Related Topics å¹¿åº¦ä¼˜å…ˆæœç´¢ å›¾ æœ€çŸ­è·¯ ğŸ‘ 80 ğŸ‘ 0

#define MAXN               10000
#define MAXM               40000
#define DYNAMIC_ARRAY_SIZE 0x100

typedef struct {
    int pos, time;
} data_t;
typedef struct {
    int front;
    int rear;
    int capacity;
    data_t *data;
} queue_t;
void queue_push(queue_t *queue, data_t val) {
    if (queue->rear == queue->capacity) {
        queue->data = realloc(queue->data, (queue->capacity += DYNAMIC_ARRAY_SIZE) * sizeof(data_t));
    }
    queue->data[queue->rear++] = val;
}

int idx, h[MAXN + 1], e[MAXM], ne[MAXM];
void edge_record(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}
int secondMinimum(int n, int **edges, int size, int *colSize, int time, int change) {
    int min[n + 1][2];
    queue_t queue[1] = { 0 };

    // record edges
    idx = 0;
    memset(min, -1, sizeof(min));
    memset(h, -1, (n + 1) * sizeof(int));
    for (int i = 0; i < size; ++i) {
        edge_record(edges[i][0], edges[i][1]);
        edge_record(edges[i][1], edges[i][0]);
    }

    queue_push(queue, (data_t) { 1, min[1][0] = 0 });
    for (data_t now; min[n][1] == -1 && queue->front < queue->rear; ++queue->front) {
        now = queue->data[queue->front];

        // ç­‰ç¯
        if (now.time % (change * 2) >= change) now.time = now.time / change * change + change;

        for (int i = h[now.pos]; i >= 0; i = ne[i]) {
            int next = now.time + time;
            if (min[e[i]][0] == -1) {
                min[e[i]][0] = next;
            } else if (min[e[i]][0] == next) {
                continue;
            } else if (min[e[i]][1] == -1) {
                min[e[i]][1] = next;
            } else {
                continue;
            }
            queue_push(queue, (data_t) { e[i], next });
        }
    }

    free(queue->data);

    return min[n][1];
}