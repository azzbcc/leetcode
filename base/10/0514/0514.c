// ç”µå­æ¸¸æˆâ€œè¾å°„4â€ä¸­ï¼Œä»»åŠ¡â€œé€šå‘è‡ªç”±â€è¦æ±‚çŽ©å®¶åˆ°è¾¾åä¸ºâ€œFreedom Trail Ringâ€çš„é‡‘å±žè¡¨ç›˜ï¼Œå¹¶ä½¿ç”¨è¡¨ç›˜æ‹¼å†™ç‰¹å®šå…³é”®è¯æ‰èƒ½å¼€é—¨ã€‚
//
// ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² ringï¼Œè¡¨ç¤ºåˆ»åœ¨å¤–çŽ¯ä¸Šçš„ç¼–ç ï¼›ç»™å®šå¦ä¸€ä¸ªå­—ç¬¦ä¸²
// keyï¼Œè¡¨ç¤ºéœ€è¦æ‹¼å†™çš„å…³é”®è¯ã€‚æ‚¨éœ€è¦ç®—å‡ºèƒ½å¤Ÿæ‹¼å†™å…³é”®è¯ä¸­æ‰€æœ‰å­—ç¬¦çš„æœ€å°‘æ­¥æ•°ã€‚
//
// æœ€åˆï¼Œring çš„ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸Ž12:00æ–¹å‘å¯¹é½ã€‚æ‚¨éœ€è¦é¡ºæ—¶é’ˆæˆ–é€†æ—¶é’ˆæ—‹è½¬ ring ä»¥ä½¿ key çš„ä¸€ä¸ªå­—ç¬¦åœ¨ 12:00
// æ–¹å‘å¯¹é½ï¼Œç„¶åŽæŒ‰ä¸‹ä¸­å¿ƒæŒ‰é’®ï¼Œ\ä»¥æ­¤é€ä¸ªæ‹¼å†™å®Œ key ä¸­çš„æ‰€æœ‰å­—ç¬¦ã€‚
//
// æ—‹è½¬ ring æ‹¼å‡º key å­—ç¬¦ key[i] çš„é˜¶æ®µä¸­ï¼š
//
//
// æ‚¨å¯ä»¥å°† ring é¡ºæ—¶é’ˆæˆ–é€†æ—¶é’ˆæ—‹è½¬ä¸€ä¸ªä½ç½®ï¼Œè®¡ä¸º1æ­¥ã€‚æ—‹è½¬çš„æœ€ç»ˆç›®çš„æ˜¯å°†å­—ç¬¦ä¸² ring çš„ä¸€ä¸ªå­—ç¬¦ä¸Ž 12:00
// æ–¹å‘å¯¹é½ï¼Œå¹¶ä¸”è¿™ä¸ªå­—ç¬¦å¿…é¡»ç­‰äºŽå­—ç¬¦ key[i] ã€‚ å¦‚æžœå­—ç¬¦ key[i]
// å·²ç»å¯¹é½åˆ°12:00æ–¹å‘ï¼Œæ‚¨éœ€è¦æŒ‰ä¸‹ä¸­å¿ƒæŒ‰é’®è¿›è¡Œæ‹¼å†™ï¼Œè¿™ä¹Ÿå°†ç®—ä½œ 1 æ­¥ã€‚æŒ‰å®Œä¹‹åŽï¼Œæ‚¨å¯ä»¥å¼€å§‹æ‹¼å†™ key
// çš„ä¸‹ä¸€ä¸ªå­—ç¬¦ï¼ˆä¸‹ä¸€é˜¶æ®µï¼‰, ç›´è‡³å®Œæˆæ‰€æœ‰æ‹¼å†™ã€‚
//
//
// ç¤ºä¾‹ï¼š
//
// è¾“å…¥: ring = "godding", key = "gd"
// è¾“å‡º: 4
// è§£é‡Š:
//  å¯¹äºŽ key çš„ç¬¬ä¸€ä¸ªå­—ç¬¦ 'g'ï¼Œå·²ç»åœ¨æ­£ç¡®çš„ä½ç½®, æˆ‘ä»¬åªéœ€è¦1æ­¥æ¥æ‹¼å†™è¿™ä¸ªå­—ç¬¦ã€‚
//  å¯¹äºŽ key çš„ç¬¬äºŒä¸ªå­—ç¬¦ 'd'ï¼Œæˆ‘ä»¬éœ€è¦é€†æ—¶é’ˆæ—‹è½¬ ring "godding" 2æ­¥ä½¿å®ƒå˜æˆ "ddinggo"ã€‚
//  å½“ç„¶, æˆ‘ä»¬è¿˜éœ€è¦1æ­¥è¿›è¡Œæ‹¼å†™ã€‚
//  å› æ­¤æœ€ç»ˆçš„è¾“å‡ºæ˜¯ 4ã€‚
//
//
// æç¤ºï¼š
//
//
// ring å’Œ key çš„å­—ç¬¦ä¸²é•¿åº¦å–å€¼èŒƒå›´å‡ä¸º 1 è‡³ 100ï¼›
// ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸­éƒ½åªæœ‰å°å†™å­—ç¬¦ï¼Œå¹¶ä¸”å‡å¯èƒ½å­˜åœ¨é‡å¤å­—ç¬¦ï¼›
// å­—ç¬¦ä¸² key ä¸€å®šå¯ä»¥ç”±å­—ç¬¦ä¸² ring æ—‹è½¬æ‹¼å‡ºã€‚
//
// Related Topics æ·±åº¦ä¼˜å…ˆæœç´¢ åˆ†æ²»ç®—æ³• åŠ¨æ€è§„åˆ’
// ðŸ‘ 129 ðŸ‘Ž 0
#define WIDTH 26
#define MAXN  100
typedef struct {
    int pos;
    int count;
} node_t;
int dist(int old, int now, int len) {
    int d = (old + len - now) % len;
    if (d > len / 2) d = len - d;
    return d;
}
int findRotateSteps(char *ring, char *key) {
    node_t nodes[2][MAXN];
    int map[WIDTH][MAXN + 1] = { 0 }, len = 0;

    for (; ring[len]; ++len) {
        map[ring[len] - 'a'][++map[ring[len] - 'a'][0]] = len;
    }

    int possible = map[*key - 'a'][0];
    for (int i = 1; i <= possible; ++i) {
        nodes[0][i - 1] = (node_t) { map[*key - 'a'][i], dist(0, map[*key - 'a'][i], len) + 1 };
    }

    int now = 0;
    while (*++key) {
        for (int i = 1, count, pos; i <= map[*key - 'a'][0]; ++i) {
            pos = map[*key - 'a'][i], count = nodes[now][0].count + dist(pos, nodes[now][0].pos, len) + 1;
            for (int j = 1, tmp; j < possible; ++j) {
                tmp = nodes[now][j].count + dist(pos, nodes[now][j].pos, len) + 1;
                if (count > tmp) count = tmp;
            }
            nodes[1 - now][i - 1] = (node_t) { pos, count };
        }
        possible = map[*key - 'a'][0], now = 1 - now;
    }

    int ans = nodes[now][0].count;
    for (int i = 1; i < possible; ++i) {
        if (ans > nodes[now][i].count) ans = nodes[now][i].count;
    }

    return ans;
}
